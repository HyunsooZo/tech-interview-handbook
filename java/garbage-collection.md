---
icon: trash-can-list
---

# Garbage Collection

**Q.** 가비지 컬렉션이 뭔가요?\



**A.** 가비지 컬렉션은 프로그램에서 더 이상 필요 없는 객체, 즉 참조가 끊긴 메모리를 자동으로 정리하는 기법입니다. \
예를 들어, 책상에 안 쓰는 물건이 쌓이면 새 물건을 올릴 자리가 없듯이, \
메모리도 마찬가지로 정리해야 새 객체를 위한 공간이 생깁니다. \
이걸 통해 메모리 낭비를 막고 개발 부담을 줄여줍니다.

**Q.** 가비지 컬렉션의 주요 방식은 어떤 게 있나요?\



**A.** 대표적으로 세 가지가 있습니다:

1. **참조 카운팅**: 객체의 참조 수를 세서 0이 되면 메모리를 회수. 간단하지만 순환 참조 처리에 약점이 있습니다.
2. **마크 앤 스위프**: GC 루트에서 도달 가능한 객체를 표시하고, 표시 안 된 객체를 정리. 순환 참조도 문제없습니다.
3. **복사 수집**: 살아있는 객체를 새 메모리로 옮기고 기존 메모리를 비움. Java의 Young Generation에서 주로 쓰이고 빠릅니다.

**Q.** 마크 앤 스위프가 순환 참조를 처리할 수 있는 이유는 뭔가요?\



**A.** 마크 앤 스위프는 참조 수를 보지 않고, GC 루트에서 객체까지 도달 가능한지를 확인합니다. \
**마크 단계**에서 루트부터 접근 가능한 객체를 표시하고, **스위프 단계**에서 표시 안 된 객체를 회수합니다. \
순환 참조 객체가 루트에서 도달 불가능하면 표시되지 않아 정리됩니다. 이게 참조 카운팅과 다른 점입니다.

**Q.** 자바에서 가비지 컬렉션은 어떻게 작동하나요?\



**A.** 자바는 자동으로 가비지 컬렉션을 처리해 개발자가 메모리를 직접 해제할 필요가 없습니다. \
객체가 참조를 잃으면(예: 변수가 null이 되면) 가비지로 간주됩니다. \
힙 메모리는 **Young Generation**과 **Old Generation**으로 나뉘는데, \
새 객체는 Young에서 빠르게 **Minor GC**로 정리되고, 오래 살아남은 객체는 Old로 가서 **Major GC**로 처리됩니다. \
Major GC는 **Stop-the-World**로 프로그램이 잠깐 멈출 수 있습니다.

**Q.** 자바의 주요 GC 알고리즘은 어떤 게 있나요?\



**A.** 주요 GC 알고리즘은 다음과 같습니다:

1. **Serial GC**: 단일 스레드로 GC를 처리. Stop-the-World 시간이 길어 소규모 환경에 적합.
2. **Parallel GC**: Java 8까지 기본 GC. Young Generation에서 멀티 스레드를 써서 속도가 빠름.
3. **Parallel Old GC**: Parallel GC 확장판으로, Old Generation도 멀티 스레드로 처리. **Mark-Summary-Compact**로 메모리 조각을 정리.
4. **G1 GC**: Java 9부터 기본. 힙을 Region으로 나눠 Garbage가 많은 곳부터 청소. 지연 시간 관리에 강점.
5. **Shenandoah GC와 ZGC**: 최신 GC로, Stop-the-World 시간을 밀리초 단위로 줄여 대규모 서버에 최적화.

**Q.** G1 GC의 특징과 장점은 뭔가요?\



**A.** G1 GC는 힙을 작은 Region으로 나눠 관리하며, \
Garbage가 많은 Region을 우선 정리합니다. Young/Old를 유연하게 다루고, \
Stop-the-World 시간을 예측 가능하게 줄여줍니다. 특히 지연 시간이 중요한 대규모 애플리케이션에서 효율적입니다.
