---
icon: shield-halved
---

# Spring Security

## Q. 스프링 시큐리티에서 인증과 인가를 담당하는 주요 클래스들은 어떤 건가요?

**A.** \
스프링 시큐리티에서 인증과 인가는 보안의 핵심입니다.\
&#x20;인증은 사용자가 누구인지 확인하는 과정이고,\
&#x20;인가는 그 사용자가 어떤 권한을 가졌는지 확인합니다.&#x20;

주요 클래스들을 말씀드리자면, 먼저 **AuthenticationManager**가 인증을 담당합니다. \
사용자가 입력한 아이디나 비밀번호 같은 정보를 검증하는 역할을 하며. 주로 **ProviderManager**라는 구현체가 쓰입니다.

인가 쪽에서는 **AccessDecisionManager**가 중요한데, \
이건 사용자가 특정 리소스에 접근할 권한이 있는지 판단합니다. \
예를 들어, 관리자만 접근 가능한 페이지에 일반 사용자가 들어가려고 하면 여기서 걸러집니다.\
&#x20;또, **FilterSecurityInterceptor**는 HTTP 요청이 들어왔을 때 마지막으로 권한을 체크하는 필터입니다. \
URL별로 어떤 보안 설정을 적용할지 결정하는 역할을 합니다.

그리고 **UserDetailsService**는 데이터베이스나 다른 저장소에서 사용자 정보를 가져오는 역할을 합니다. \
로그인할 때 사용자 데이터를 조회해서 인증에 활용하합니다.&#x20;

사용자 권한은 **GrantedAuthority**로 관리하는데, \
보통 **SimpleGrantedAuthority**로 ‘ROLE\_ADMIN’ 같은 권한을 설정합니다. \
메소드 단위로 권한을 체크할 때는 **@PreAuthorize** 같은 어노테이션을 쓰면 더 세밀한 제어가 가능합니다.

***

## Q. **SecurityFilterChain**은 스프링 시큐리티에서 어떤 역할을 하나요?

**A.** **SecurityFilterChain**은 스프링 시큐리티에서 HTTP 요청을 보안 관점에서 처리하는 \
필터들의 흐름을 관리하는 핵심적인 부분입니다.\
즉 요청이 들어왔을 때 어떤 보안 절차를 거쳐야 하는지 정리하는 역할을 합니다. \
예를 들어, \
특정 URL, 가령 “/character” 같은 경로에 접근하려면 로그인해야 한다거나, 특정 권한이 있어야 한다고 설정합니다.

이건 **HttpSecurity**를 통해 설정하는데, 여기서 인증이나 인가 같은 보안 정책을 URL별로 정의합니다.\
&#x20;예를 들어, **FilterSecurityInterceptor** 같은 필터가 마지막 단계에서 “이 요청을 허용할지, 말지”를 판단합니다. \
그래서 **SecurityFilterChain**은 보안 설정을 체계적으로 관리하는 큰 틀이라고 보시면 됩니다.

***

## Q. **@PreAuthorize**와 **@Secured**의 차이점은 뭔가요?

**A.** \
&#xNAN;**@PreAuthorize**와 **@Secured**는 메소드 단위로 권한을 체크할 때 쓰는 어노테이션입니다. \
&#xNAN;**@Secured**는 단순하게 역할 기반으로 체크합니다. 예를 들어, `@Secured("ROLE_ADMIN")`을 쓰면\
&#x20;“이 메소드는 관리자 권한이 있어야 실행된다” 이렇게 설정하는 셈입니다.

반면 **@PreAuthorize**는 훨씬 유연합니다. \
스프링 표현 언어(SpEL)를 지원해서 더 복잡한 로직을 넣을 수 있습니다. \
예를 들어, `@PreAuthorize("hasRole('ROLE_ADMIN') or #id == authentication.principal.id")` \
이렇게 쓰면 “관리자거나, 이 캐릭터의 소유자만 실행 가능” 이런 식으로 세밀한 조건을 설정할 수 있습니다\
. 그래서 간단한 경우엔 **@Secured**, 복잡한 권한 로직이 필요하면 **@PreAuthorize**를 쓰는 게 적합합니다.

***

## Q. 스프링 시큐리티에서 JWT 인증은 어떻게 구현하나요?

**A.** JWT 인증은 요즘 많이 쓰이는 방식입니다. \
세션을 사용하지 않고 토큰으로 인증을 처리하는 거라서 stateless한 환경에 잘 맞습니다. \
흐름을 간단히 설명드리자면, \
먼저 사용자가 로그인 요청을 보내면 서버에서 사용자 정보를 확인한 뒤 \
JWT 토큰을 만들어서 클라이언트에 돌려줍니다. \
이 토큰에는 사용자 정보와 권한 같은 게 포함되어 있습니다.

그다음, 클라이언트가 요청할 때마다 이 토큰을 헤더에 넣어서 보냅니다.\
&#x20;서버에서는 이 토큰을 받아서 유효한지, 예를 들어 서명이 맞는지, 만료되지 않았는지 확인합니다. \
유효하면 그 토큰을 바탕으로 사용자 정보를 꺼내서 인증 상태를 유지합니다.\
&#x20;이 과정에서 **SecurityContextHolder**에 사용자 정보를 저장해서 이후 권한 체크에 활용합니다.

예를 들어, “/character/{id}” 같은 요청이 들어오면, \
설정에서 이 URL은 로그인한 사용자만 접근 가능하다고 해놓고, \
토큰이 유효한지 확인한 뒤 처리하는 식입니다.\
&#x20;JWT는 세션을 안 쓰니까 서버 부담도 줄고, 분산 환경에서도 유용하게 쓰입니다.

***

## Q. **UserDetailsService**와 **UserDetails**는 어떤 역할을 하나요?

**A.** \
**UserDetailsService**와 **UserDetails**는 인증 과정에서 핵심적인 역할을 합니다. \
먼저 **UserDetailsService**는 사용자 정보를 가져오는 인터페이스입니다.\
&#x20;예를 들어, 사용자가 로그인하려고 아이디를 입력하면, \
이 인터페이스를 통해 데이터베이스나 다른 저장소에서 그 사용자의 정보를 찾아옵니다. \
주로 아이디, 비밀번호, 권한 같은 정보를 가져와서 인증에 사용합니다.

**UserDetails**는 그 사용자 정보를 담는 객체의 인터페이스입니다. \
여기엔 사용자 이름, 비밀번호, 그리고 권한 목록 같은 게 포함됩니다.\
스프링 시큐리티에서 기본으로 제공하는 **User** 클래스를 쓰거나, \
필요하면 커스텀해서 사용할 수 있습니다.\
&#x20;예를 들어, 로그인할 때 **UserDetailsService**가 **UserDetails**를 만들어서 반환하면, \
이 정보가 인증 과정에서 **Authentication** 객체에 담겨서 이후 인가나 보안 처리에 쓰입니다.

***

## Q. **SecurityContextHolder**는 스프링 시큐리티에서 어떤 역할을 하나요?

**A.** \
**SecurityContextHolder**는 현재 요청의 보안 정보를 저장하는 역할을 합니다. \
쉽게 말하면, 지금 로그인한 사용자가 누구인지, 어떤 권한을 가지고 있는지를 기억하는 저장소 입니다.\
이 정보는 **Authentication** 객체에 담겨서 스레드 단위로 관리됩니다.

예를 들어, “/character/{id}” 요청을 처리할 때, 이 사용자가 로그인한 상태인지, \
이 캐릭터를 수정할 권한이 있는지 확인하려면 **SecurityContextHolder**에서 사용자 정보를 꺼내서 체크합니다.\
코드 없이 말로 설명하자면, \
이건 애플리케이션 어디서든 현재 사용자 정보를 쉽게 가져올 수 있게 해주는 중심점 같은 역할을 합니다. \
다만, 비동기 작업 같은 특수 상황에서는 스레드 간 정보 공유를 위해 추가 설정이 필요할 수 있습니다.

***

## Q. 스프링 시큐리티에서 **OAuth2** 인증은 어떻게 동작하나요?

**A.** **OAuth2**는 구글, 깃허브 같은 외부 서비스로 인증을 처리하는 방식입니다. \
흐름을 간단히 말씀드리자면, \
사용자가 로그인하려고 하면, 예를 들어 “구글로 로그인”을 클릭하면 스프링이 사용자를 구글 로그인 페이지로 보내줍니다. \
사용자가 거기서 로그인하면 구글에서 토큰을 발급해 주고, 스프링은 이 토큰을 받아서 유효한지 확인합니다.

그다음, 이 토큰으로 사용자 정보를 가져와서 인증 상태를 만듭니다. \
이 정보는 **SecurityContextHolder**에 저장돼서 이후 요청에서 \
“이 사용자는 인증된 사용자야”라고 판단하는 데 쓰입니다. \
예를 들어, “/character/{id}” 같은 요청이 들어오면, \
이 사용자가 로그인한 상태인지, 필요한 권한이 있는지 확인해서 처리합니다.&#x20;

**OAuth2**는 외부 인증을 활용해서 편리하게 로그인 기능을 구현할 수 있고, \
사용자 정보를 우리 데이터베이스에 연동해서 커스텀할 수도 있습니다.

***

## Q. 스프링 시큐리티에서 **CSRF** 보호는 왜 필요한가요? 어떻게 설정하나요?

**A.** \
**CSRF**는 악의적인 사이트가 사용자의 브라우저를 이용해서 서버에 위조 요청을 보내는 공격입니다. \
예를 들어, 사용자가 로그인한 상태에서 악성 사이트가 “/character/{id}”로 PUT 요청을 몰래 보내면, \
사용자가 모르게 데이터가 바뀔 수 있습니다. \
스프링 시큐리티는 이런 공격을 막기 위해 CSRF 보호를 기본으로 켜놓고 있습니다.

CSRF 보호는 POST, PUT 같은 요청에 CSRF 토큰을 요구합니다. \
클라이언트가 이 토큰을 폼이나 헤더에 포함해서 보내야 요청이 처리되는 방식입니다. \
웹 애플리케이션에서는 보통 폼에 숨겨진 필드로 토큰을 넣거나, AJAX 요청 시 헤더에 추가합니다. \
설정은 기본적으로 활성화돼 있어서 따로 건드릴 필요는 없지만, \
REST API처럼 세션이 없는 경우엔 CSRF 보호를 꺼도 괜찮습니다.\
&#x20;대신, 그럴 땐 JWT 같은 다른 인증 방식을 잘 써야 보안이 유지됩니다.

***

## Q. 스프링 시큐리티에서 **커스텀 인증 필터**는 언제, 어떻게 만드나요?

**A.** \
**커스텀 인증 필터**는 기본 인증 방식, \
예를 들어 아이디와 비밀번호만으로 처리할 수 없는 특별한 인증이 필요할 때 만듭니다. \
예를 들어, API 키로 인증하거나, SMS 인증 같은 걸 추가하고 싶을 때 사용합니다.

만드는 과정은, \
먼저 요청에서 필요한 정보를 뽑아서 인증을 시도합니다.\
&#x20;예를 들어, “/character/{id}” 요청에 API 키를 헤더로 보냈다면, \
이 키를 확인해서 유효한지 판단합니다.&#x20;

이 로직을 커스텀 필터에 넣고, 유효한 키면 사용자 정보를 만들어서 인증 상태를 설정합니다. \
이걸 스프링의 보안 체인에 추가해서 기본 인증 필터 대신 동작하게 합니다. \
중요한 건, 이 필터가 **AuthenticationManager**와 연동돼서 인증 결과를 처리한다는 점입니다. \
이렇게 하면 특이한 인증 방식도 유연하게 구현할 수 있습니다.
