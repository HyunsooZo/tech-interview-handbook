---
icon: arrow-progress
---

# Transaction

## **Q1. 트랜잭션이란 무엇인가요?**

## **A.**

트랜잭션은 여러 작업을 하나의 논리적 단위로 묶어 처리하는 것입니다. \
쉽게 말해, 모든 작업이 성공하거나 모두 실패해야 하는 작업 묶음입니다. \
예를 들어, 은행 계좌 이체에서 A 계좌 출금과 B 계좌 입금은 반드시 함께 성공하거나 실패해야 합니다. \
실패 시 롤백(rollback)으로 원상복구됩니다.

***

## **Q2. ACID 속성에 대해 설명해주세요.**

## **A.**

ACID는 트랜잭션의 안정성을 보장하는 4가지 속성입니다:

* **Atomicity (원자성)**: 모든 작업이 전부 성공하거나 전부 실패해야 합니다. 중간 상태는 허용되지 않습니다.
* **Consistency (일관성)**: 트랜잭션 전후로 데이터가 비즈니스 규칙과 무결성을 유지해야 합니다.
* **Isolation (격리성)**: 여러 트랜잭션이 동시에 실행되더라도 서로 간섭 없이 독립적으로 처리됩니다.
* **Durability (지속성)**: 트랜잭션이 커밋되면 시스템 장애가 발생해도 데이터가 영구적으로 보존됩니다.

***

## **Q3. 트랜잭션 격리 수준(Isolation Level)이란 무엇인가요?**

## **A.**&#x20;

격리 수준은 여러 트랜잭션이 동시에 실행될 때 데이터 일관성과 성능을 조절하는 설정입니다. \
주요 격리 수준은 다음과 같습니다:

* **Read Uncommitted**: 다른 트랜잭션의 커밋되지 않은 데이터를 읽을 수 있어 Dirty Read 발생 가능.
* **Read Committed**: 커밋된 데이터만 읽지만, Non-Repeatable Read 발생 가능.
* **Repeatable Read**: 동일 트랜잭션 내에서 같은 데이터를 반복 읽어도 동일한 결과 보장. Phantom Read 가능.
* **Serializable**: 완전 격리로 모든 트랜잭션이 순차적으로 실행되며 가장 엄격하지만 성능 저하 가능.
* **예시**: MySQL의 기본 격리 수준은 Repeatable Read로, 데이터 일관성과 성능의 균형을 맞춥니다.

***

## **Q4. 데드락(Deadlock)이란 무엇이고, 어떻게 방지하나요?**

## **A.**

데드락은 두 개 이상의 트랜잭션이 서로가 가진 자원을 기다리며 무한 대기 상태에 빠지는 상황입니다.

* **발생 예시**: 트랜잭션 A가 테이블 X를 잠그고 Y를 기다릴 때, 트랜잭션 B가 Y를 잠그고 X를 기다리는 경우.
* **방지 방법**:
  1. 자원 접근 순서 고정(예: 항상 테이블 X → Y 순으로 잠금).
  2. 타임아웃 설정으로 데드락 감지 후 롤백.
  3. 트랜잭션 크기 최소화로 잠금 시간 단축.
* **예시**: MySQL에서는 innodb\_deadlock\_detect 설정으로 데드락을 감지하고 자동 롤백합니다.

***

## **Q5. MVCC(Multi-Version Concurrency Control)란 무엇인가요?**

## **A.**

MVCC는 다중 버전 동시성 제어로, 트랜잭션이 데이터의 스냅샷을 사용해 격리성을 보장하는 방식입니다.

* **동작 방식**: 트랜잭션이 시작될 때 데이터의 특정 시점 버전을 읽어, 다른 트랜잭션의 변경 사항에 영향을 받지 않습니다.
* **장점**: 읽기와 쓰기 간의 충돌을 줄여 동시성을 향상시킵니다.
* **예시**: MySQL InnoDB나 PostgreSQL에서 MVCC를 사용해 Repeatable Read 격리 수준을 구현합니다.

***

## **Q6. JPA에서 트랜잭션은 어떻게 처리하나요?**

## **A.**

JPA(Java Persistence API)에서는 @Transactional 애너테이션으로 트랜잭션을 관리합니다.

* **동작 방식**:
  1. @Transactional이 붙은 메서드 내에서 DB 작업이 하나의 트랜잭션으로 묶입니다.
  2. 메서드 실행 완료 시 자동 커밋, 예외 발생 시 자동 롤백.
