---
icon: object-ungroup
---

# 데이터베이스 정규화

## Q. 데이터베이스의 정규화(Normalization)는 무엇이며, 왜 필요한가요?

**A.**\
데이터베이스 정규화는 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위해 테이블을 구조화하는 설계 과정입니다.\
&#x20;이를 통해 삽입, 삭제, 갱신 시 발생할 수 있는 **이상 현상**(Insertion, Deletion, Update Anomalies)을 방지합니다. \
예를 들어, \
고객 정보와 주문 정보가 단일 테이블에 섞여 있으면 고객 데이터가 중복 저장되어 갱신 시 \
불일치가 발생할 수 있습니다. \
정규화는 데이터를 논리적으로 분리해 이러한 문제를 해결합니다.

* **장점**:
  * 데이터 중복 감소로 저장 공간 절약.
  * 데이터 일관성과 무결성 유지.
  * 데이터 변경 시 이상 현상 방지.
* **단점**: 과도한 정규화는 테이블 분리로 인해 조인 연산이 증가하여 조회 성능이 저하될 수 있습니다.

정규화는 데이터 무결성이 중요한 애플리케이션(예: 금융 시스템)에서 필수적입니다.

## Q. 정규화로 인한 성능 저하 문제를 해결할 수 있는 방법은 있나요?

**A.**\
정규화로 인한 성능 저하, 특히 조인 연산 증가로 인한 읽기 성능 저하를 해결하기 위해 \
**반정규화(Denormalization)**&#xB97C; 사용할 수 있습니다. \
반정규화는 의도적으로 데이터 중복을 허용하거나 테이블을 병합해 조인 횟수를 줄이는 방식입니다.

* **예시**: 자주 조회되는 데이터를 단일 테이블에 통합해 조인을 최소화.
* **장점**: 읽기 성능 향상, 쿼리 단순화.
* **단점**: 데이터 중복으로 저장 공간 증가, 갱신 시 무결성 관리 복잡성 증가.

따라서 데이터베이스 설계 시 읽기 성능이 중요한 경우(예: 리포팅 시스템)에는 \
정규화와 반정규화를 균형 있게 적용해야 합니다. \
추가로, 인덱스 최적화나 캐싱 전략(예: Redis)을 활용해 성능을 보완할 수 있습니다.

## Q. 정규화는 어떤 방식으로 진행되나요?

**A.**\
정규화는 데이터베이스 테이블을 여러 단계로 나누어 이상 현상을 제거하는 체계적인 과정입니다. \
주요 단계는 다음과 같습니다:

* **제1 정규형(1NF)**\
  각 컬럼에 단일 값만 저장하도록 분리하고, 반복 그룹을 제거합니다.\
  &#x20;예: 하나의 셀에 여러 전화번호를 저장하지 않고 별도 행으로 분리.
* **제2 정규형(2NF)**\
  1NF를 만족하며, 기본 키의 일부에 종속된 컬럼(부분 함수 종속)을 별도 테이블로 분리합니다. \
  예: 주문 테이블에서 고객 정보(기본 키와 무관)를 별도 테이블로 분리.
* **제3 정규형(3NF)**\
  2NF를 만족하며, 기본 키가 아닌 컬럼 간의 종속성(이행 함수 종속)을 제거합니다. \
  예: 학생 테이블에서 학과 코드와 학과 이름을 분리.
* **보이스-코드 정규형(BCNF)**\
  3NF를 만족하며, 모든 결정자가 후보 키인 조건을 충족하도록 설계합니다.

일반적으로 BCNF까지 적용하면 대부분의 이상 현상이 제거되며, \
제4 정규형(4NF)과 제5 정규형(5NF)은 다중값 종속이나 복잡한 조인 종속을 다룰 때 사용되지만, \
실무에서는 드물게 적용됩니다.

## Q. 정규화와 반정규화의 적용 시 어떤 트레이드오프를 고려해야 하나요?

**A.**\
정규화와 반정규화는 데이터베이스 설계에서 성능과 무결성 간의 트레이드오프를 고려해야 합니다.

* **정규화**:
  * **장점**: 데이터 중복 최소화, 무결성 보장, 데이터 변경 시 이상 현상 방지.
  * **단점**: 조인 증가로 읽기 성능 저하, 쿼리 복잡성 증가.
  * **적합 사례**: 쓰기 작업이 많고 무결성이 중요한 시스템(예: 은행, 전자상거래).
* **반정규화**:
  * **장점**: 조인 감소로 읽기 성능 향상, 쿼리 단순화.
  * **단점**: 데이터 중복으로 저장 공간 증가, 갱신 시 무결성 관리 비용 증가.
  * **적합 사례**: 읽기 작업이 빈번한 시스템(예: 분석 대시보드, 검색 엔진).

트레이드오프를 고려할 때는 시스템의 요구사항(읽기/쓰기 비율, 데이터 일관성 우선순위)과 \
하드웨어 자원(스토리지, 캐싱 여부)을 분석해야 합니다. \
예를 들어, 읽기 성능이 중요한 경우 반정규화와 인덱스 최적화를 병행하고, \
무결성이 우선이라면 정규화를 유지하되 캐싱(예: Redis)이나 뷰(View)를 활용해 성능을 보완할 수 있습니다.
